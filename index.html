<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Skin Tone Classifier & Makeup Shade Recommender</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style-custom.css" />
    <script src="face-api.min.js"></script>
    <script src="face-api.min.js.map"></script>
    <style>
      body {
        background: #f7f7f7;
        font-family: "Montserrat", Arial, sans-serif;
      }
      .neo-brutal {
        background: #fff;
        border: 4px solid #222;
        border-radius: 18px;
        box-shadow: 8px 8px 0 #222;
        padding: 2rem;
        margin-bottom: 2rem;
      }
      .neo-btn {
        background: #ffde03;
        color: #222;
        border: 3px solid #222;
        border-radius: 10px;
        font-weight: bold;
        box-shadow: 4px 4px 0 #222;
        transition: 0.1s;
      }
      .neo-btn:active {
        box-shadow: 1px 1px 0 #222;
        transform: translate(2px, 2px);
      }
      .canvas-preview,
      #videoPreview {
        max-width: 320px;
        border-radius: 12px;
        border: 3px solid #222;
        box-shadow: 4px 4px 0 #222;
        margin-bottom: 1rem;
        background: #fff;
      }
      #dropZone {
        min-height: 60px;
        cursor: pointer;
      }
      #stopCameraBtn {
        display: none;
      }
      .shade-info {
        background: #ffde03;
        border-left: 6px solid #222;
        padding: 1rem;
        border-radius: 10px;
        font-weight: bold;
        color: #222;
        box-shadow: 4px 4px 0 #222;
      }
      .countdown {
        font-size: 2rem;
        font-weight: bold;
        color: #e63946;
        margin-bottom: 1rem;
      }
      .face-box {
        position: absolute;
        border: 3px solid #27ae60;
        border-radius: 8px;
        pointer-events: none;
      }
      .relative {
        position: relative;
        display: inline-block;
      }
      #videoPreview {
        display: none;
      }
      #faceCanvas {
        display: none;
      }
      #imagePreview img,
      #imagePreview canvas,
      .result-img {
        max-width: 100% !important;
        height: auto !important;
        display: inline-block;
        box-sizing: border-box;
      }
      @media (max-width: 600px) {
        .neo-brutal,
        .container {
          padding: 0.5rem !important;
        }
        #imagePreview img,
        #imagePreview canvas,
        .result-img {
          max-width: 98vw !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="container-fluid" style="min-height: 100vh">
      <div class="row">
        <!-- Sidebar -->
        <nav class="col-md-3 col-lg-2 d-md-block sidebar py-4">
          <div class="sidebar-sticky">
            <h2 class="text-center mb-4">KLASIFIKASI WARNA KULIT</h2>
            <ul class="nav flex-column mb-4">
              <li class="nav-item mb-2">
                <a class="nav-link active" href="#main-area"
                  ><i class="bi bi-person-square"></i> Klasifikasi</a
                >
              </li>
              <li class="nav-item mb-2">
                <a class="nav-link" href="#gallery"
                  ><i class="bi bi-palette"></i> Galeri Warna Kulit</a
                >
              </li>
              <li class="nav-item mb-2">
                <a class="nav-link" href="#about"
                  ><i class="bi bi-info-circle"></i> Tentang</a
                >
              </li>
              <li class="nav-item mb-2">
                <a class="nav-link" href="#guide"
                  ><i class="bi bi-question-circle"></i> Panduan</a
                >
              </li>
            </ul>
            <div class="text-center mt-5">
              <!-- teks ini project di hosting di github pages, silahkan cek repository -->
              <h5>Source code tersedia di github</h5>
              <a href="https://github.com/primahagantha/skin-shade-recommender">
                <img
                  src="https://cdn-icons-png.flaticon.com/512/2111/2111425.png"
                  width="50"
                  height="50"
                  alt="Github Repository"
                  style="opacity: 0.7"
                />
              </a>
              <div class="mt-2" style="font-size: 0.9em; color: #888">versi 1.2</div>
            </div>
          </div>
        </nav>
        <!-- Main Content -->
        <main class="col-md-9 col-lg-10 ms-sm-auto px-4 py-4" id="main-area">
          <!-- Mode Switcher (moved to bottom) -->
          <!-- Skin Tone Gallery -->
          <section id="about" class="neo-brutal mb-4">
            <h3><span class="bi bi-info-circle"></span> Tentang Proyek</h3>
            <p>
              Banyak orang masih kesulitan memilih shade make-up yang cocok
              dengan warna kulitnya. Aplikasi ini membantu pengguna menentukan
              shade make-up yang sesuai secara otomatis dan real-time
              menggunakan kamera atau upload gambar.<br /><br />
              Sistem ini memanfaatkan teknik pengolahan citra digital seperti
              Gaussian Blur, Fourier Transform, Sobel, Wiener Filter, penambahan
              Gaussian Noise, dan segmentasi warna kulit dengan K-Means
              Clustering. Semua proses dilakukan langsung di browser tanpa
              library image processing khusus.<br /><br />
              Dengan aplikasi ini, pengguna bisa mendapatkan rekomendasi shade
              make-up yang lebih tepat dan hasil riasan yang natural.
            </p>
          </section>
          <section id="gallery" class="mb-5">
            <h3 class="mb-3">
              <span class="bi bi-palette"></span> Galeri Warna Kulit &
              Rekomendasi
            </h3>
            <div class="row row-cols-1 row-cols-md-3 g-4">
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="gallery-img-container">
                    <div class="gallery-img-container">
                      <img
                        src="img/white.png"
                        class="card-img-top gallery-img"
                        alt="Kulit Putih"
                      />
                      <div class="gallery-edu-note">
                        Gambar untuk kebutuhan pendidikan
                      </div>
                    </div>
                  </div>
                  <div class="card-body">
                    <h5 class="card-title">Ivory (Putih)</h5>
                    <p class="card-text">
                      Cocok untuk kulit putih cerah.<br />Rekomendasi shade:
                      <b>Ivory</b>.
                    </p>
                  </div>
                </div>
              </div>
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="gallery-img-container">
                    <div class="gallery-img-container">
                      <img
                        src="img/medium.jpg"
                        class="card-img-top gallery-img"
                        alt="Kulit Sawo Matang"
                      />
                      <div class="gallery-edu-note">
                        Gambar untuk kebutuhan pendidikan
                      </div>
                    </div>
                  </div>
                  <div class="card-body">
                    <h5 class="card-title">Beige (Sawo Matang)</h5>
                    <p class="card-text">
                      Cocok untuk kulit sawo matang.<br />Rekomendasi shade:
                      <b>Natural Beige</b>.
                    </p>
                  </div>
                </div>
              </div>
              <div class="col">
                <div class="card h-100 shadow-sm">
                  <div class="gallery-img-container">
                    <div class="gallery-img-container">
                      <img
                        src="img/tan.png"
                        class="card-img-top gallery-img"
                        alt="Kulit Gelap"
                      />
                      <div class="gallery-edu-note">
                        Gambar untuk kebutuhan pendidikan
                      </div>
                    </div>
                  </div>
                  <div class="card-body">
                    <h5 class="card-title">Tan (Gelap)</h5>
                    <p class="card-text">
                      Cocok untuk kulit gelap.<br />Rekomendasi shade:
                      <b>Beige</b>.
                    </p>
                  </div>
                </div>
              </div>
            </div>
            <div class="mt-3 text-muted">
              <b>Catatan:</b> Penggunaan gambar pada galeri ini hanya untuk
              kebutuhan pendidikan dan referensi visual. Hasil klasifikasi dapat
              berbeda tergantung kondisi foto.<br />Seluruh gambar hanya
              digunakan untuk kebutuhan pendidikan.
            </div>
          </section>
          <!-- Upload Area -->
          <section class="neo-brutal mb-4" id="modeSwitcher">
            <h4 class="mb-3 text-center">Pilih Mode</h4>
            <div class="d-flex justify-content-center gap-3 flex-wrap">
              <button
                id="btnModeUpload"
                class="neo-btn btn btn-outline-primary btn-lg"
                type="button"
              >
                <i class="bi bi-upload"></i> Upload Gambar
              </button>
              <button
                id="btnModeCamera"
                class="neo-btn btn btn-outline-success btn-lg"
                type="button"
              >
                <i class="bi bi-camera-video"></i> Kamera Realtime
              </button>
            </div>
          </section>
          <section class="neo-brutal mb-4" id="uploadArea">
            <h1 class="mb-3 text-center">
              <span class="bi bi-upload"></span> Upload Gambar Wajah
            </h1>
            <p class="lead text-center">
              Aplikasi web untuk klasifikasi warna kulit dan rekomendasi shade
              make up berbasis pengolahan citra digital secara manual.
            </p>
            <div class="mb-4">
              <label for="imageInput" class="form-label">
                <i class="bi bi-image"></i> Upload Foto Wajah (JPG/PNG):
              </label>
              <input
                class="form-control mb-2"
                type="file"
                id="imageInput"
                accept="image/*"
                multiple
              />
              <div class="input-group mb-2">
                <input
                  type="text"
                  id="imageUrlInput"
                  class="form-control"
                  placeholder="Tempel link gambar .png/.cmd di sini"
                />
                <button class="neo-btn btn btn-warning" id="addImageUrlBtn">
                  <i class="bi bi-link-45deg"></i> Upload dari Link
                </button>
              </div>
              <div
                id="dropZone"
                class="mt-2 p-3 border border-2 border-dark rounded bg-light text-center"
              >
                <i class="bi bi-cloud-arrow-up"></i> Drag & Drop atau Ctrl+V
                gambar di sini
              </div>
            </div>
            <div id="previewBefore" class="mb-3"></div>
            <div id="imagePreview" class="mb-4"></div>
            <div id="previewAfter" class="mb-3"></div>
            <button
              class="neo-btn btn btn-danger mb-3"
              id="processBtnUpload"
              disabled
            >
              <i class="bi bi-magic"></i> Proses Gambar
            </button>
            <div id="resultsUpload"></div>
          </section>
          <!-- Camera Area -->
          <section class="neo-brutal mb-4" id="cameraArea">
            <h1 class="mb-3 text-center">
              <span class="bi bi-camera-video"></span> Kamera Realtime
            </h1>
            <p class="lead text-center">
              Untuk hasil maksimal, pastikan pencahayaan cukup dan wajah
              terlihat jelas di kamera.
            </p>
            <div class="mb-3">
              <label for="cameraSelect" class="form-label">
                <i class="bi bi-camera"></i> Pilih Kamera:
              </label>
              <div class="input-group mb-2">
                <select class="form-select" id="cameraSelect"></select>
                <div id="cameraPermMsg" class="form-text text-danger mt-1" style="display:none"></div>
                <button class="neo-btn btn btn-success" id="startCameraBtn">
                  <i class="bi bi-camera-video"></i> Aktifkan Kamera
                </button>
                <button class="neo-btn btn btn-secondary" id="stopCameraBtn">
                  <i class="bi bi-x-circle"></i> Non-aktifkan Kamera
                </button>
              </div>
              <div class="form-text mb-2">
                Kamera akan mengambil 5 foto secara otomatis dalam 5 detik.
              </div>
              <div class="form-text mb-2">
                <i class="bi bi-lightbulb"></i> Tips: Pastikan wajah menghadap
                kamera dan pencahayaan cukup terang.
              </div>
              <div id="cameraStatus" class="form-text"></div>
              <div class="relative">
                <video id="videoPreview" autoplay></video>
                <canvas id="faceCanvas"></canvas>
              </div>
              <div class="countdown" id="countdown"></div>
            </div>
            <div id="imagePreview" class="mb-4"></div>
                          <button
                class="neo-btn btn btn-danger mb-2"
                id="captureBtn"
                disabled
              >
                <i class="bi bi-magic"></i> Ambil 5 Foto (5 Detik)
              </button>
            <button
              class="neo-btn btn btn-danger mb-3 d-flex"
              id="processBtnCamera"
              disabled
            >
              <i class="bi bi-magic"></i> Proses Gambar
            </button>
            <div id="resultsCamera"></div>
          </section>
          <!-- About & Guide -->

          <section id="guide" class="neo-brutal mb-4">
            <!-- Mode Switcher (moved to bottom) -->

            <h3><i class="bi bi-question-circle"></i> Panduan Penggunaan</h3>
            <ol>
              <li>
                <b>Upload foto wajah</b> melalui tombol
                <i class="bi bi-upload"></i> atau gunakan kamera langsung.
              </li>
              <li>
                <b>Jika menggunakan kamera</b>, pilih kamera yang tersedia lalu
                klik <i class="bi bi-camera-video"></i> Aktifkan Kamera. Setelah
                aktif, klik <i class="bi bi-camera"></i> Ambil 5 Foto.
              </li>
              <li>
                <b>Setelah foto muncul di preview</b>, klik
                <i class="bi bi-magic"></i> Proses Gambar untuk memulai
                klasifikasi.
              </li>
              <li>
                Setiap tahap pengolahan citra (blur, noise, segmentasi, dsb)
                akan divisualisasikan di bawah.
              </li>
              <li>
                Hasil klasifikasi warna kulit dan rekomendasi shade make up akan
                muncul di bagian bawah.
              </li>
              <li>
                <b>Catatan:</b> Pastikan pencahayaan cukup dan wajah terlihat
                jelas untuk hasil terbaik.
              </li>
            </ol>
          </section>
        </main>
      </div>
    </div>
    <script>
      // Mode switching logic
      let currentMode = "upload";
      function showMode(mode) {
        var upload = document.getElementById("uploadArea");
        var camera = document.getElementById("cameraArea");
        var btnUpload = document.getElementById("processBtnUpload");
        var btnCamera = document.getElementById("processBtnCamera");
        if (mode === "upload") {
          upload.style.display = "block";
          camera.style.display = "none";
          btnUpload.disabled = false;
          btnCamera.disabled = true;
        } else {
          camera.style.display = "block";
          upload.style.display = "none";
          btnCamera.disabled = false;
          btnUpload.disabled = true;
        }
        currentMode = mode;
      }
      // Request camera permission on load (if not already granted/denied)
      async function requestCameraPermissionIfNeeded() {
        if (!navigator.permissions || !navigator.mediaDevices) return;
        try {
          const status = await navigator.permissions.query({ name: 'camera' });
          // Show message if denied
          let permMsg = document.getElementById("cameraPermMsg");
          if (permMsg) {
            if (status.state === 'denied') {
              permMsg.textContent = "Akses kamera tidak diizinkan. Silakan aktifkan permission kamera di browser Anda.";
              permMsg.style.display = "block";
            } else {
              permMsg.style.display = "none";
            }
          }
          if (status.state === 'prompt') {
            // Try to get camera stream to trigger permission prompt
            navigator.mediaDevices.getUserMedia({ video: true })
              .then(stream => {
                stream.getTracks().forEach(track => track.stop());
              })
              .catch(() => {});
          }
        } catch (e) {
          // Fallback: try to getUserMedia anyway (older browsers)
          navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
              stream.getTracks().forEach(track => track.stop());
            })
            .catch(() => {});
        }
      }

      document.addEventListener("DOMContentLoaded", function () {
        showMode("upload"); // default
        requestCameraPermissionIfNeeded();
        document.getElementById("btnModeUpload").onclick = function () {
          showMode("upload");
        };
        document.getElementById("btnModeCamera").onclick = function () {
          showMode("camera");
        };
      });
      // Tunggu faceapi siap sebelum menjalankan kode utama
      function waitForFaceApiReady(cb) {
        if (window.faceapi) cb();
        else setTimeout(() => waitForFaceApiReady(cb), 100);
      }
      waitForFaceApiReady(function () {
        let imgDataUrl = null;
        let imgElement = null;
        let stream = null;
        let currentDeviceId = null;
        let faceDetModelLoaded = false;
        let faceBoxes = [];
        let capturedImages = [];
        let detectFaceLoopRequestId = null;

        // Kamera: Enumerasi device
        async function updateCameraList() {
          const select = document.getElementById("cameraSelect");
          select.innerHTML = "";
          // Hide permission message by default
          let permMsg = document.getElementById("cameraPermMsg");
          if (permMsg) permMsg.style.display = "none";
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter((d) => d.kind === "videoinput");
            videoDevices.forEach((device, idx) => {
              const option = document.createElement("option");
              option.value = device.deviceId;
              let label = device.label || `Kamera ${idx + 1}`;
              if (label.toLowerCase().includes("back"))
                label = `Kamera Belakang`;
              if (label.toLowerCase().includes("front")) label = `Kamera Depan`;
              option.text = label;
              select.appendChild(option);
            });

            
            if (videoDevices.length === 0) {
              select.innerHTML =
                '<option value="">Tidak ada kamera terdeteksi</option>';
            }
          } catch (e) {
            select.innerHTML =
              '<option value="">Tidak bisa mengakses kamera</option>';
          }
        }
        updateCameraList();
        navigator.mediaDevices.addEventListener(
          "devicechange",
          updateCameraList
        );

        // Load face-api.js models
        async function loadFaceModel() {
          if (faceDetModelLoaded) return;
          await faceapi.nets.tinyFaceDetector.loadFromUri("./weights");
          faceDetModelLoaded = true;
        }
        loadFaceModel();

        document.getElementById("startCameraBtn").onclick = async function () {
          const select = document.getElementById("cameraSelect");
          const deviceId = select.value;
          if (!deviceId) return;
          // Selalu stop stream lama sebelum memulai baru
          if (stream) {
            stream.getTracks().forEach((track) => track.stop());
            stream = null;
          }
          // Cancel face detection loop jika ada
          if (detectFaceLoopRequestId) {
            cancelAnimationFrame(detectFaceLoopRequestId);
            detectFaceLoopRequestId = null;
          }
          // Reset preview image area
          let previewDiv = document.querySelector("#cameraArea #imagePreview");
          if (previewDiv) previewDiv.innerHTML = "";
          // Reset faceCanvases
          window.faceCanvases = [];
          // Disable dropdown saat kamera aktif
          select.disabled = true;
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: { deviceId: { exact: deviceId } },
              audio: false,
            });
            currentDeviceId = deviceId;
            const video = document.getElementById("videoPreview");
            video.srcObject = stream;
            video.style.display = "block";
            document.getElementById("faceCanvas").style.display = "block";
            document.getElementById("captureBtn").disabled = false;
            document.getElementById("cameraStatus").textContent = "Kamera aktif.";
            document.getElementById("stopCameraBtn").style.display = "inline-block";
            document.getElementById("startCameraBtn").style.display = "none";
            // Disable dropdown saat kamera aktif
            select.disabled = true;
            console.log("Kamera diaktifkan");
            detectFaceLoop();
            // Hide permission message if success
            let permMsg = document.getElementById("cameraPermMsg");
            if (permMsg) permMsg.style.display = "none";
          } catch (e) {
            document.getElementById("cameraStatus").textContent = "Gagal mengaktifkan kamera.";
            // Enable dropdown jika gagal
            select.disabled = false;
            console.log("Gagal mengaktifkan kamera", e);
            // Show permission message if error is permission
            let permMsg = document.getElementById("cameraPermMsg");
            if (permMsg && (e && (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError'))) {
              permMsg.textContent = "Akses kamera tidak diizinkan. Silakan aktifkan permission kamera di browser Anda.";
              permMsg.style.display = "block";
            }
          }
        };

        document.getElementById("stopCameraBtn").onclick = function () {
          if (stream) {
            stream.getTracks().forEach((track) => track.stop());
            stream = null;
          }
          // Cancel face detection loop jika ada
          if (detectFaceLoopRequestId) {
            cancelAnimationFrame(detectFaceLoopRequestId);
            detectFaceLoopRequestId = null;
          }
          // Reset video preview
          const video = document.getElementById("videoPreview");
          video.style.display = "none";
          video.srcObject = null;
          document.getElementById("faceCanvas").style.display = "none";
          document.getElementById("captureBtn").disabled = true;
          document.getElementById("cameraStatus").textContent = "Kamera non-aktif.";
          document.getElementById("stopCameraBtn").style.display = "none";
          document.getElementById("startCameraBtn").style.display = "inline-block";
          // Enable dropdown saat kamera non-aktif
          document.getElementById("cameraSelect").disabled = false;
          // Reset preview image area
          let previewDiv = document.querySelector("#cameraArea #imagePreview");
          if (previewDiv) previewDiv.innerHTML = "";
          // Reset faceCanvases
          window.faceCanvases = [];
          console.log("Kamera dinonaktifkan");
        };

        async function detectFaceLoop() {
          const video = document.getElementById("videoPreview");
          const canvas = document.getElementById("faceCanvas");
          if (!faceDetModelLoaded) await loadFaceModel();
          function drawFaceBox(box) {
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (box) {
              ctx.strokeStyle = "#27ae60";
              ctx.lineWidth = 3;
              ctx.strokeRect(box.x, box.y, box.width, box.height);
            }
          }
          async function loop() {
            if (!stream) return; // Stop loop if stream is gone
            if (video.readyState === 4) {
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              canvas.style.width = video.style.width = video.offsetWidth + "px";
              canvas.style.height = video.style.height = video.offsetHeight + "px";
              const detections = await faceapi.detectSingleFace(
                video,
                new faceapi.TinyFaceDetectorOptions()
              );
              if (detections) {
                drawFaceBox(detections.box);
                faceBoxes[0] = detections.box;
              } else {
                drawFaceBox(null);
                faceBoxes[0] = null;
              }
            }
            detectFaceLoopRequestId = requestAnimationFrame(loop);
          }
          detectFaceLoopRequestId = requestAnimationFrame(loop);
        }
        // Kamera: Ganti device, auto nonaktifkan kamera jika sedang aktif
        document.getElementById("cameraSelect").addEventListener("change", function () {
          // Jika kamera sedang aktif, matikan dulu
          if (stream) {
            document.getElementById("stopCameraBtn").click();
          }
          // Status info
          document.getElementById("cameraStatus").textContent = "Kamera siap. Silakan klik 'Aktifkan Kamera' untuk memulai kamera baru.";
        });

        document.getElementById("captureBtn").onclick = async function () {
          capturedImages = [];
          let countdown = document.getElementById("countdown");
          countdown.textContent = "";
          window.faceCanvases = [];
          // Make sure preview is in camera area, not upload area
          let previewDiv = document.querySelector("#cameraArea #imagePreview");
          previewDiv.innerHTML = "";
          for (let i = 5; i >= 1; i--) {
            countdown.textContent = `Ambil foto dalam ${i} detik...`;
            await new Promise((r) => setTimeout(r, 1000));
            const video = document.getElementById("videoPreview");
            let canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            let ctx = canvas.getContext("2d");
            ctx.drawImage(video, 0, 0);
            // Proses face-api pada hasil capture
            if (faceDetModelLoaded) {
              const detections = await faceapi.detectAllFaces(
                canvas,
                new faceapi.TinyFaceDetectorOptions()
              );
              if (detections.length) {
                detections.forEach((det, idx) => {
                  const { x, y, width, height } = det.box;
                  let faceCanvas = document.createElement("canvas");
                  faceCanvas.width = 256;
                  faceCanvas.height = 256;
                  faceCanvas
                    .getContext("2d")
                    .drawImage(canvas, x, y, width, height, 0, 0, 256, 256);
                  previewDiv.appendChild(faceCanvas);
                  window.faceCanvases.push(faceCanvas);
                  console.log(`Wajah ke-${idx + 1} dari kamera diproses`);
                });
              } else {
                // Jika tidak ada wajah, simpan full frame
                let fullCanvas = document.createElement("canvas");
                fullCanvas.width = canvas.width;
                fullCanvas.height = canvas.height;
                fullCanvas.getContext("2d").drawImage(canvas, 0, 0);
                previewDiv.appendChild(fullCanvas);
                window.faceCanvases.push(fullCanvas);
                console.log(
                  "Tidak ada wajah terdeteksi pada kamera, proses gambar penuh"
                );
              }
            } else {
              // fallback jika model belum siap
              previewDiv.appendChild(canvas);
              window.faceCanvases.push(canvas);
            }
          }
          countdown.textContent = "Foto selesai!";
          document.getElementById("processBtn").disabled = false;
          console.log("Semua foto dari kamera siap diproses");
        };

        document
          .getElementById("imageInput")
          .addEventListener("change", function (e) {
            const files = e.target.files;
            if (!files.length) return;
            const reader = new FileReader();
            reader.onload = function (ev) {
              let img = new window.Image();
              img.src = ev.target.result;
              img.onload = function () {
                processUploadedImage(img);
                document.getElementById("processBtn").disabled = false;
              };
            };
            Array.from(files).forEach((file) => {
              reader.readAsDataURL(file);
            });
          });

        // Fungsi upload file multiple, drag & drop, paste, dan link
        function handleFiles(files) {
          if (!files || !files.length) return;
          console.log("Files uploaded:", files);
          let previewDiv = document.getElementById("imagePreview");
          previewDiv.innerHTML = "";
          Array.from(files).forEach((file, idx) => {
            if (!file.type.startsWith("image/")) return;
            const reader = new FileReader();
            reader.onload = function (ev) {
              let img = new window.Image();
              img.src = ev.target.result;
              img.onload = function () {
                processUploadedImage(img);
                document.getElementById("processBtn").disabled = false;
                console.log(`Gambar ke-${idx + 1} siap diproses`);
              };
            };
            reader.readAsDataURL(file);
          });
        }
        document
          .getElementById("imageInput")
          .addEventListener("change", function (e) {
            handleFiles(e.target.files);
          });
        // Drag & drop
        const dropZone = document.getElementById("dropZone");
        dropZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropZone.classList.add("bg-warning");
        });
        dropZone.addEventListener("dragleave", (e) => {
          e.preventDefault();
          dropZone.classList.remove("bg-warning");
        });
        dropZone.addEventListener("drop", (e) => {
          e.preventDefault();
          dropZone.classList.remove("bg-warning");
          handleFiles(e.dataTransfer.files);
        });
        // Paste
        dropZone.addEventListener("paste", (e) => {
          let items = e.clipboardData.items;
          let files = [];
          for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
              files.push(items[i].getAsFile());
            }
          }
          handleFiles(files);
        });
        // Paste global (Ctrl+V di mana saja)
        window.addEventListener("paste", (e) => {
          let items = e.clipboardData.items;
          let files = [];
          for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
              files.push(items[i].getAsFile());
            }
          }
          if (files.length) {
            handleFiles(files);
            dropZone.classList.add("bg-success");
            setTimeout(() => dropZone.classList.remove("bg-success"), 1000);
          }
        });
        // Upload dari link
        document.getElementById("addImageUrlBtn").onclick = function () {
          const url = document.getElementById("imageUrlInput").value.trim();
          if (!url.match(/\.(png|cmd)$/i)) {
            alert("Hanya link .png atau .cmd yang didukung!");
            return;
          }
          let img = new window.Image();
          img.crossOrigin = "anonymous";
          img.src = url;
          img.onload = function () {
            processUploadedImage(img);
            document.getElementById("processBtn").disabled = false;
            console.log("Gambar dari link siap diproses");
          };
          img.onerror = function () {
            alert("Gagal memuat gambar dari link!");
          };
        };

        // Drag & Drop
        (function () {
          const dropZone = document.getElementById("dropZone");
          dropZone.addEventListener("dragover", (e) => {
            e.preventDefault();
            dropZone.classList.add("bg-warning", "text-dark");
          });
          dropZone.addEventListener("dragleave", (e) => {
            e.preventDefault();
            dropZone.classList.remove("bg-warning", "text-dark");
          });
          dropZone.addEventListener("drop", (e) => {
            e.preventDefault();
            dropZone.classList.remove("bg-warning", "text-dark");
            const files = e.dataTransfer.files;
            if (files.length) {
              const reader = new FileReader();
              reader.onload = function (ev) {
                let img = new window.Image();
                img.src = ev.target.result;
                img.onload = function () {
                  processUploadedImage(img);
                  document.getElementById("processBtn").disabled = false;
                };
              };
              Array.from(files).forEach((file) => {
                reader.readAsDataURL(file);
              });
            }
          });
        })();

        // Array global untuk menyimpan hasil crop wajah/canvas
        window.faceCanvases = [];
        async function processUploadedImage(img) {
          if (!window.faceapi) {
            alert("face-api.js belum siap!");
            return;
          }
          // Preview sebelum deteksi wajah (selalu 500x500 agar konsisten)
          let previewBefore = document.getElementById("previewBefore");
          previewBefore.innerHTML =
            "<b>Preview Sebelum Deteksi Wajah (500x500):</b><br>";
          let beforeCanvas = document.createElement("canvas");
          beforeCanvas.width = 500;
          beforeCanvas.height = 500;
          let beforeCtx = beforeCanvas.getContext("2d");
          // Gambar di-center dan scale to fit (tanpa crop, preserve aspect ratio)
          let imgW = img.width || img.naturalWidth || 256;
          let imgH = img.height || img.naturalHeight || 256;
          let scale = Math.min(500 / imgW, 500 / imgH);
          let drawW = imgW * scale;
          let drawH = imgH * scale;
          let dx = (500 - drawW) / 2;
          let dy = (500 - drawH) / 2;
          beforeCtx.fillStyle = "#fff";
          beforeCtx.fillRect(0, 0, 500, 500);
          beforeCtx.drawImage(img, 0, 0, imgW, imgH, dx, dy, drawW, drawH);
          previewBefore.appendChild(beforeCanvas);

          const detections = await faceapi.detectAllFaces(
            img,
            new faceapi.TinyFaceDetectorOptions()
          );
          let previewDiv = document.getElementById("imagePreview");
          let previewAfter = document.getElementById("previewAfter");
          previewDiv.innerHTML = "";
          previewAfter.innerHTML = "";
          window.faceCanvases = [];
          if (!detections.length) {
            // Tidak ada wajah: proses gambar full size, jangan resize/crop
            let canvas = document.createElement("canvas");
            canvas.width = img.width || img.naturalWidth || 256;
            canvas.height = img.height || img.naturalHeight || 256;
            let ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            previewDiv.appendChild(canvas);
            window.faceCanvases.push(canvas);
            previewAfter.innerHTML =
              '<div class="alert alert-warning mt-2">Wajah tidak terdeteksi. Gambar akan diproses penuh tanpa crop wajah.</div>';
            console.log("Tidak ada wajah terdeteksi, proses gambar penuh");
            return;
          }
          // Jika ada wajah, tampilkan preview crop wajah
          previewAfter.innerHTML = "<b>Preview Setelah Deteksi Wajah:</b><br>";
          detections.forEach((det, idx) => {
            const { x, y, width, height } = det.box;
            if (width > 50 && height > 50) {
              let canvas = document.createElement("canvas");
              canvas.width = 256;
              canvas.height = 256;
              let ctx = canvas.getContext("2d");
              ctx.drawImage(img, x, y, width, height, 0, 0, 256, 256);
              previewDiv.appendChild(canvas);
              window.faceCanvases.push(canvas);
              // Tampilkan juga di previewAfter
              let cropLabel = document.createElement("div");
              cropLabel.style.fontSize = "0.95em";
              cropLabel.style.marginBottom = "4px";
              cropLabel.innerHTML = `Wajah ke-${idx + 1}`;
              previewAfter.appendChild(cropLabel);
              previewAfter.appendChild(canvas.cloneNode(true));
              console.log(`Wajah ke-${idx + 1} diproses`);
            }
          });
        }

        function drawToCanvas(img, processFn, caption) {
          // Pastikan img adalah elemen gambar atau canvas
          let canvas = document.createElement("canvas");
          let ctx = canvas.getContext("2d");
          let width = 256,
            height = 256;
          if (img instanceof HTMLImageElement) {
            width = img.naturalWidth || img.width || 256;
            height = img.naturalHeight || img.height || 256;
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          } else if (img instanceof HTMLCanvasElement) {
            width = img.width || 256;
            height = img.height || 256;
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0);
          } else {
            // Jika bukan img/canvas, skip dan return kosong
            let div = document.createElement("div");
            div.innerHTML = "<small>Gambar tidak valid</small>";
            return div;
          }
          if (processFn) {
            let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            processFn(imgData);
            ctx.putImageData(imgData, 0, 0);
          }
          let div = document.createElement("div");
          div.appendChild(canvas);
          if (caption) {
            let cap = document.createElement("div");
            cap.innerHTML = `<small>${caption}</small>`;
            div.appendChild(cap);
          }
          return div;
        }

        function grayscale(imgData) {
          for (let i = 0; i < imgData.data.length; i += 4) {
            let r = imgData.data[i],
              g = imgData.data[i + 1],
              b = imgData.data[i + 2];
            let gray = 0.299 * r + 0.587 * g + 0.114 * b;
            imgData.data[i] = imgData.data[i + 1] = imgData.data[i + 2] = gray;
          }
        }

        // function gaussianBlur(imgData) {
        //   // Gaussian blur kernel 3x3
        //   let w = imgData.width,
        //     h = imgData.height;
        //   let src = new Uint8ClampedArray(imgData.data);
        //   let kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
        //   let ksum = 16;
        //   for (let y = 1; y < h - 1; y++) {
        //     for (let x = 1; x < w - 1; x++) {
        //       for (let c = 0; c < 3; c++) {
        //         let sum = 0,
        //           idx = 0;
        //         for (let dy = -1; dy <= 1; dy++)
        //           for (let dx = -1; dx <= 1; dx++)
        //             sum +=
        //               src[4 * ((y + dy) * w + (x + dx)) + c] * kernel[idx++];
        //         imgData.data[4 * (y * w + x) + c] = sum / ksum;
        //       }
        //     }
        //   }
        // }

        function addNoise(imgData) {
          for (let i = 0; i < imgData.data.length; i += 4) {
            let noise = (Math.random() - 0.5) * 40;
            imgData.data[i] = Math.min(
              255,
              Math.max(0, imgData.data[i] + noise)
            );
            imgData.data[i + 1] = Math.min(
              255,
              Math.max(0, imgData.data[i + 1] + noise)
            );
            imgData.data[i + 2] = Math.min(
              255,
              Math.max(0, imgData.data[i + 2] + noise)
            );
          }
        }

        function sobelEdge(imgData) {
          let w = imgData.width,
            h = imgData.height;
          let src = new Uint8ClampedArray(imgData.data);
          let gx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
          let gy = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
          for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
              let sx = 0,
                sy = 0;
              for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                  let val = src[4 * ((y + ky) * w + (x + kx))];
                  let idx = (ky + 1) * 3 + (kx + 1);
                  sx += gx[idx] * val;
                  sy += gy[idx] * val;
                }
              }
              let mag = Math.sqrt(sx * sx + sy * sy);
              imgData.data[4 * (y * w + x)] =
                imgData.data[4 * (y * w + x) + 1] =
                imgData.data[4 * (y * w + x) + 2] =
                  mag;
            }
          }
        }

        function segmentSkin(imgData) {
          for (let i = 0; i < imgData.data.length; i += 4) {
            let r = imgData.data[i],
              g = imgData.data[i + 1],
              b = imgData.data[i + 2];
            if (
              !(
                r > 95 &&
                g > 40 &&
                b > 20 &&
                r > g &&
                r > b &&
                Math.abs(r - g) > 15
              )
            ) {
              imgData.data[i] = imgData.data[i + 1] = imgData.data[i + 2] = 128;
            }
          }
        }

        function classifySkinTone(imgData) {
          let total = 0,
            sumR = 0,
            sumG = 0,
            sumB = 0;
          for (let i = 0; i < imgData.data.length; i += 4) {
            let r = imgData.data[i],
              g = imgData.data[i + 1],
              b = imgData.data[i + 2];
            if (!(r === 128 && g === 128 && b === 128)) {
              sumR += r;
              sumG += g;
              sumB += b;
              total++;
            }
          }
          if (total === 0)
            return {
              tone: "Tidak Terdeteksi",
              shade: "-",
              info: "-",
              link: "#",
            };
          let mean = (sumR + sumG + sumB) / (3 * total);
          console.log(
            `Total Rata-Rata RGB: ${mean.toFixed(
              2
            )} (${sumR}, ${sumG}, ${sumB}) dari ${total} piksel`
          );
          console.log(`Totatl Mean: ${mean}  dari ${total} piksel`);

          if (mean >= 180) {
            return {
              tone: "White",
              shade: "Ivory",
              info: "Cocok untuk skin tone white dengan bedak shade Ivory",
              link: "https://www.google.com/search?q=bedak+terbaik+untuk+kulit+putih+ivory",
            };
          } else if (mean >= 100) {
            return {
              tone: "Brown/Tan/Medium",
              shade: "Natural Beige ",
              info: "Cocok untuk skin tone medium bedak shade Natural Beige.",
              link: "https://www.google.com/search?q=bedak+terbaik+untuk+kulit+sawo+matang+beige+natural",
            };
          } else {
            return {
              tone: "Tan",
              shade: "Beige",
              info: "Cocok untuk bedak shade Beige.",
              link: "https://www.google.com/search?q=bedak+terbaik+untuk+kulit+gelap+beige",
            };
          }
        }

        // --- PREPROCESSING FUNCTIONS ---
        function resizeToStandard(imgData, size = 256) {
          // Resize image to standard size (256x256)
          let canvas = document.createElement("canvas");
          canvas.width = size;
          canvas.height = size;
          let ctx = canvas.getContext("2d");
          let tmp = document.createElement("canvas");
          tmp.width = imgData.width;
          tmp.height = imgData.height;
          tmp.getContext("2d").putImageData(imgData, 0, 0);
          ctx.drawImage(tmp, 0, 0, size, size);
          return ctx.getImageData(0, 0, size, size);
        }

        function gammaCorrection(imgData, gamma = 2.2) {
          let invGamma = 1 / gamma;
          for (let i = 0; i < imgData.data.length; i += 4) {
            imgData.data[i] = 255 * Math.pow(imgData.data[i] / 255, invGamma);
            imgData.data[i + 1] =
              255 * Math.pow(imgData.data[i + 1] / 255, invGamma);
            imgData.data[i + 2] =
              255 * Math.pow(imgData.data[i + 2] / 255, invGamma);
          }
        }

        function gaussianBlur(imgData) {
          // Gaussian blur kernel 3x3
          let w = imgData.width,
            h = imgData.height;
          let src = new Uint8ClampedArray(imgData.data);
          let kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
          let ksum = 16;
          for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0,
                  idx = 0;
                for (let dy = -1; dy <= 1; dy++)
                  for (let dx = -1; dx <= 1; dx++)
                    sum +=
                      src[4 * ((y + dy) * w + (x + dx)) + c] * kernel[idx++];
                imgData.data[4 * (y * w + x) + c] = sum / ksum;
              }
            }
          }
        }

        // --- WIENER FILTER (deblurring) ---
        function wienerFilter(imgData, kernelSize = 3, K = 0.01) {
          // Simple Wiener filter for grayscale image
          let w = imgData.width,
            h = imgData.height;
          let src = new Float32Array(imgData.data.length);
          for (let i = 0; i < imgData.data.length; i++)
            src[i] = imgData.data[i];
          // Gaussian kernel
          let kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
          let ksum = 16;
          function convolve(src) {
            let dst = new Float32Array(src.length);
            for (let y = 1; y < h - 1; y++) {
              for (let x = 1; x < w - 1; x++) {
                for (let c = 0; c < 3; c++) {
                  let sum = 0,
                    idx = 0;
                  for (let dy = -1; dy <= 1; dy++)
                    for (let dx = -1; dx <= 1; dx++)
                      sum +=
                        src[4 * ((y + dy) * w + (x + dx)) + c] * kernel[idx++];
                  dst[4 * (y * w + x) + c] = sum / ksum;
                }
                dst[4 * (y * w + x) + 3] = src[4 * (y * w + x) + 3];
              }
            }
            return dst;
          }
          let blurred = convolve(src);
          for (let i = 0; i < src.length; i++) {
            let powerBlur = blurred[i] * blurred[i];
            imgData.data[i] = Math.max(
              0,
              Math.min(255, (src[i] * powerBlur) / (powerBlur + K))
            );
          }
        }

        // --- COLOR SPACE CONVERSIONS ---
        function rgb2hsv(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          let max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          let h,
            s,
            v = max;
          let d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max === min) h = 0;
          else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return [h * 360, s * 100, v * 100];
        }
        function rgb2lab(r, g, b) {
          // sRGB to CIE Lab
          function pivotX(x) {
            return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
          }
          r /= 255;
          g /= 255;
          b /= 255;
          // sRGB to XYZ
          r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
          g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
          b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
          let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
          let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.0;
          let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
          x = pivotX(x);
          y = pivotX(y);
          z = pivotX(z);
          let L = 116 * y - 16;
          let a = 500 * (x - y);
          let b_ = 200 * (y - z);
          return [L, a, b_];
        }
        function rgb2ycbcr(r, g, b) {
          let y = 0.299 * r + 0.587 * g + 0.114 * b;
          let cb = 128 - 0.168736 * r - 0.331264 * g + 0.5 * b;
          let cr = 128 + 0.5 * r - 0.418688 * g - 0.081312 * b;
          return [y, cb, cr];
        }

        // --- K-MEANS CLUSTERING FOR SKIN SEGMENTATION ---
        function kmeansSegment(imgData, k = 2, maxIter = 10) {
          // Use HSV for clustering
          let pixels = [];
          for (let i = 0; i < imgData.data.length; i += 4) {
            let r = imgData.data[i],
              g = imgData.data[i + 1],
              b = imgData.data[i + 2];
            let hsv = rgb2hsv(r, g, b);
            pixels.push(hsv);
          }
          // Initialize centroids randomly
          let centroids = [];
          for (let i = 0; i < k; i++)
            centroids.push(pixels[Math.floor(Math.random() * pixels.length)]);
          let labels = new Array(pixels.length);
          for (let iter = 0; iter < maxIter; iter++) {
            // Assign
            for (let i = 0; i < pixels.length; i++) {
              let minDist = Infinity,
                minIdx = 0;
              for (let j = 0; j < k; j++) {
                let d = Math.sqrt(
                  Math.pow(pixels[i][0] - centroids[j][0], 2) +
                    Math.pow(pixels[i][1] - centroids[j][1], 2) +
                    Math.pow(pixels[i][2] - centroids[j][2], 2)
                );
                if (d < minDist) {
                  minDist = d;
                  minIdx = j;
                }
              }
              labels[i] = minIdx;
            }
            // Update
            let sums = Array.from({ length: k }, () => [0, 0, 0]);
            let counts = Array.from({ length: k }, () => 0);
            for (let i = 0; i < pixels.length; i++) {
              let l = labels[i];
              sums[l][0] += pixels[i][0];
              sums[l][1] += pixels[i][1];
              sums[l][2] += pixels[i][2];
              counts[l]++;
            }
            for (let j = 0; j < k; j++) {
              if (counts[j] > 0) {
                centroids[j][0] = sums[j][0] / counts[j];
                centroids[j][1] = sums[j][1] / counts[j];
                centroids[j][2] = sums[j][2] / counts[j];
              }
            }
          }
          // Find cluster with highest average skin-likeliness (use HSV: H in [0,50], S>20, V>20)
          let skinIdx = 0,
            maxScore = -1;
          for (let j = 0; j < k; j++) {
            let h = centroids[j][0],
              s = centroids[j][1],
              v = centroids[j][2];
            let score = h >= 0 && h <= 50 && s > 20 && v > 20 ? 1 : 0;
            if (score > maxScore) {
              maxScore = score;
              skinIdx = j;
            }
          }
          // Mask non-skin cluster
          for (let i = 0; i < pixels.length; i++) {
            if (labels[i] !== skinIdx) {
              imgData.data[i * 4] =
                imgData.data[i * 4 + 1] =
                imgData.data[i * 4 + 2] =
                  128;
            }
          }
        }

        // --- MAIN PROCESSING PIPELINE ---
        // --- PROSES GAMBAR: Per mode, horizontal layout ---
        function processImage(mode) {
          let resultsDiv = document.getElementById(
            mode === "upload" ? "resultsUpload" : "resultsCamera"
          );
          resultsDiv.innerHTML = "";

          // jika tidak ada gambar yang diupload
          if (mode === "upload" && window.faceCanvases.length === 0){
            resultsDiv.innerHTML =
              '<div class="alert alert-warning">Tidak ada gambar yang bisa diproses. Silakan pilih gambar untuk diupload.</div>';
            return;
          }
          // jika tidak ada result kamera ketika tekan button process gambar
          if (mode === "camera" && window.faceCanvases.length === 0) {
            resultsDiv.innerHTML =
              '<div class="alert alert-warning">Tidak ada gambar yang bisa diproses. Silakan pilih kamera -> aktifkan kamera -> ambil foto  dengan tekan tombol ambil 5 foto (5 detik)</div>';
            return;
          }
          let faceCanvases = window.faceCanvases || [];
          if (faceCanvases.length === 0) {
            resultsDiv.innerHTML =
              '<div class="alert alert-warning">Tidak ada wajah yang bisa diproses.</div>';
            return;
          }
          // Legend/keterangan langkah horizontal
          let legendDiv = document.createElement("div");
          legendDiv.className =
            "mb-2 px-2 py-2 bg-white border rounded text-center";
          legendDiv.style.fontSize = "1em";
          legendDiv.innerHTML =
            "<b>Langkah Proses:</b> " +
            '<span class="badge bg-secondary mx-1">1. Wiener Deblurring</span>' +
            '<span class="badge bg-secondary mx-1">2. Gaussian Noise</span>' +
            '<span class="badge bg-secondary mx-1">3. Gaussian Blur</span>' +
            '<span class="badge bg-secondary mx-1">4. DFT Magnitude</span>' +
            '<span class="badge bg-secondary mx-1">5. Sobel Edge</span>' +
            '<span class="badge bg-secondary mx-1">6. Segmentasi Kulit</span>' +
            '<span class="badge bg-secondary mx-1">7. K-Means Kulit</span>' +
            '<span class="badge bg-secondary mx-1">8. Klasifikasi & Rekomendasi Shade</span>';
          resultsDiv.appendChild(legendDiv);

          // List proses dan hasil per proses
          let prosesList = [
            {
              name: "Wiener Deblurring",
              key: "wiener",
              desc: "1. Wiener Deblurring (mengurangi blur pada gambar)",
            },
            {
              name: "Gaussian Noise",
              key: "noise",
              desc: "2. Gaussian Noise (menambah noise acak)",
            },
            {
              name: "Gaussian Blur",
              key: "blur",
              desc: "3. Gaussian Blur (menghaluskan gambar)",
            },
            {
              name: "DFT",
              key: "dft",
              desc: "4. DFT Magnitude (statistik frekuensi)",
            },
            {
              name: "Sobel Edge",
              key: "sobel",
              desc: "5. Sobel Edge (deteksi tepi)",
            },
            {
              name: "Segmentasi Kulit",
              key: "segment",
              desc: "6. Segmentasi Kulit (rule-based)",
            },
            {
              name: "K-Means Kulit",
              key: "kmeans",
              desc: "7. K-Means Clustering (segmentasi kulit)",
            },
            {
              name: "Klasifikasi",
              key: "klasifikasi",
              desc: "8. Klasifikasi & Rekomendasi Shade",
            },
          ];
          let rowDiv = document.createElement("div");
          rowDiv.className =
            "d-flex flex-row flex-nowrap overflow-auto gap-4 mb-3 align-items-end";
          let prosesResults = prosesList.map(() => []);
          let summary = {
            total: faceCanvases.length,
            tones: {},
            rgb: [],
            dft: [],
          };
          let toneCount = {};
          let toneInfo = [];
          faceCanvases.forEach((faceCanvas, idx) => {
            let ctx = faceCanvas.getContext("2d");
            let imgData = ctx.getImageData(
              0,
              0,
              faceCanvas.width,
              faceCanvas.height
            );
            // 1. Wiener Deblurring
            wienerFilter(imgData);
            let wienerCanvas = document.createElement("canvas");
            wienerCanvas.width = faceCanvas.width;
            wienerCanvas.height = faceCanvas.height;
            wienerCanvas.getContext("2d").putImageData(imgData, 0, 0);
            prosesResults[0].push(
              drawToCanvas(wienerCanvas, null, `Wajah ${idx + 1}`)
            );
            // 2. Gaussian Noise
            addNoise(imgData);
            let noiseCanvas = document.createElement("canvas");
            noiseCanvas.width = faceCanvas.width;
            noiseCanvas.height = faceCanvas.height;
            noiseCanvas.getContext("2d").putImageData(imgData, 0, 0);
            prosesResults[1].push(
              drawToCanvas(noiseCanvas, null, `Wajah ${idx + 1}`)
            );
            // 3. Gaussian Blur
            gaussianBlur(imgData);
            let blurCanvas = document.createElement("canvas");
            blurCanvas.width = faceCanvas.width;
            blurCanvas.height = faceCanvas.height;
            blurCanvas.getContext("2d").putImageData(imgData, 0, 0);
            prosesResults[2].push(
              drawToCanvas(blurCanvas, null, `Wajah ${idx + 1}`)
            );
            // 4. DFT
            let dftMag = dftMagnitude(imgData);
            summary.dft.push(dftMag);
            let dftDiv = document.createElement("div");
            dftDiv.innerHTML = `<small>DFT Magnitude rata-rata: ${dftMag.toFixed(
              2
            )}</small>`;
            prosesResults[3].push(dftDiv);
            // 5. Sobel Edge
            let edgeCanvas = document.createElement("canvas");
            edgeCanvas.width = faceCanvas.width;
            edgeCanvas.height = faceCanvas.height;
            let edgeImgData = new ImageData(
              new Uint8ClampedArray(imgData.data),
              imgData.width,
              imgData.height
            );
            grayscale(edgeImgData);
            sobelEdge(edgeImgData);
            edgeCanvas.getContext("2d").putImageData(edgeImgData, 0, 0);
            prosesResults[4].push(
              drawToCanvas(edgeCanvas, null, `Wajah ${idx + 1}`)
            );
            // 6. Segmentasi Kulit
            let segCanvas = document.createElement("canvas");
            segCanvas.width = faceCanvas.width;
            segCanvas.height = faceCanvas.height;
            let segImgData = new ImageData(
              new Uint8ClampedArray(imgData.data),
              imgData.width,
              imgData.height
            );
            segmentSkin(segImgData);
            segCanvas.getContext("2d").putImageData(segImgData, 0, 0);
            prosesResults[5].push(
              drawToCanvas(segCanvas, null, `Wajah ${idx + 1}`)
            );
            // 7. K-Means Kulit
            let kmeansCanvas = document.createElement("canvas");
            kmeansCanvas.width = faceCanvas.width;
            kmeansCanvas.height = faceCanvas.height;
            let kmeansImgData = new ImageData(
              new Uint8ClampedArray(segImgData.data),
              segImgData.width,
              segImgData.height
            );
            kmeansSegment(kmeansImgData, 2, 10);
            kmeansCanvas.getContext("2d").putImageData(kmeansImgData, 0, 0);
            prosesResults[6].push(
              drawToCanvas(kmeansCanvas, null, `Wajah ${idx + 1}`)
            );
            // 8. Klasifikasi
            let toneResult = classifySkinTone(kmeansImgData);
            toneCount[toneResult.tone] = (toneCount[toneResult.tone] || 0) + 1;
            summary.rgb.push(averageRGB(kmeansImgData));
            toneInfo.push(toneResult);
            let shadeDiv = document.createElement("div");
            shadeDiv.className = "shade-info mt-2 mb-2 text-center";
            shadeDiv.innerHTML = `<b>Warna Kulit:</b> ${toneResult.tone}<br><b>Shade Rekomendasi:</b> ${toneResult.shade}<br><a href="${toneResult.link}" target="_blank">Lihat Bedak di Google</a>`;
            prosesResults[7].push(shadeDiv);
          });
          // Render horizontal row: setiap kolom adalah proses, isinya hasil semua wajah
          prosesList.forEach((proses, i) => {
            let colDiv = document.createElement("div");
            colDiv.className =
              "d-flex flex-column align-items-center border p-2 rounded bg-light minw-180";
            let title = document.createElement("div");
            title.innerHTML = `<b>${proses.name}</b>`;
            colDiv.appendChild(title);
            prosesResults[i].forEach((el) => colDiv.appendChild(el));
            let desc = document.createElement("div");
            desc.className = "mt-2 text-muted text-center";
            desc.innerHTML = `<small>${proses.desc}</small>`;
            colDiv.appendChild(desc);
            rowDiv.appendChild(colDiv);
          });
          resultsDiv.appendChild(rowDiv);
          // Summary
          let summaryDiv = document.createElement("div");
          summaryDiv.className = "shade-info mt-3";
          let summaryHTML = `<b>Summary:</b><br>Jumlah wajah terdeteksi: ${summary.total}<br>`;
          Object.keys(toneCount).forEach((tone) => {
            let percent = ((toneCount[tone] / summary.total) * 100).toFixed(0);
            summaryHTML += `- ${tone}: ${toneCount[tone]} wajah (${percent}%)<br>`;
          });
          // Rata-rata RGB
          if (summary.rgb.length) {
            let avgR = 0,
              avgG = 0,
              avgB = 0;
            summary.rgb.forEach((rgb) => {
              avgR += rgb.r;
              avgG += rgb.g;
              avgB += rgb.b;
            });
            avgR = Math.round(avgR / summary.rgb.length);
            avgG = Math.round(avgG / summary.rgb.length);
            avgB = Math.round(avgB / summary.rgb.length);
            summaryHTML += `Rata-rata RGB kulit: (${avgR}, ${avgG}, ${avgB})<br>`;
          }
          // DFT summary
          if (summary.dft.length) {
            let avgDFT =
              summary.dft.reduce((a, b) => a + b, 0) / summary.dft.length;
            summaryHTML += `Rata-rata DFT Magnitude: ${avgDFT.toFixed(2)}<br>`;
          }
          // Rekomendasi shade utama (mayoritas)
          let mainTone = Object.keys(toneCount).reduce((a, b) =>
            toneCount[a] > toneCount[b] ? a : b
          );
          let mainInfo = toneInfo.find((t) => t.tone === mainTone);
          if (mainInfo) {
            summaryHTML += `<b>Rekomendasi Shade Utama:</b> ${mainInfo.shade}<br><b>Info:</b> ${mainInfo.info}<br><a href="${mainInfo.link}" target="_blank">Lihat Bedak Rekomendasi di Google</a>`;
          }
          summaryDiv.innerHTML = summaryHTML;
          resultsDiv.appendChild(summaryDiv);
        }
        // Bind process buttons
        document.addEventListener("DOMContentLoaded", function () {
          document
            .getElementById("processBtnUpload")
            .addEventListener("click", function () {
              if (currentMode === "upload") processImage("upload");
            });
          document
            .getElementById("processBtnCamera")
            .addEventListener("click", function () {
              if (currentMode === "camera") processImage("camera");
            });
        });
        // Fungsi rata-rata RGB
        function averageRGB(imgData) {
          let sumR = 0,
            sumG = 0,
            sumB = 0,
            total = 0;
          for (let i = 0; i < imgData.data.length; i += 4) {
            let r = imgData.data[i],
              g = imgData.data[i + 1],
              b = imgData.data[i + 2];
            if (!(r === 128 && g === 128 && b === 128)) {
              sumR += r;
              sumG += g;
              sumB += b;
              total++;
            }
          }
          if (total === 0) return { r: 0, g: 0, b: 0 };
          return {
            r: Math.round(sumR / total),
            g: Math.round(sumG / total),
            b: Math.round(sumB / total),
          };
        }

        // Lucy-Richardson deblurring (manual, iterasi sederhana)
        // function lucyRichardsonDeblur(imgData, iterations = 5) {
        //   // Kernel blur sederhana (Gaussian 3x3)
        //   const kernel = [
        //     1 / 16,
        //     2 / 16,
        //     1 / 16,
        //     2 / 16,
        //     4 / 16,
        //     2 / 16,
        //     1 / 16,
        //     2 / 16,
        //     1 / 16,
        //   ];
        //   const w = imgData.width,
        //     h = imgData.height;
        //   let estimate = new Float32Array(imgData.data.length);
        //   for (let i = 0; i < imgData.data.length; i++)
        //     estimate[i] = imgData.data[i];
        //   let observed = new Float32Array(imgData.data.length);
        //   for (let i = 0; i < imgData.data.length; i++)
        //     observed[i] = imgData.data[i];
        //   function convolve(src) {
        //     let dst = new Float32Array(src.length);
        //     for (let y = 1; y < h - 1; y++) {
        //       for (let x = 1; x < w - 1; x++) {
        //         for (let c = 0; c < 3; c++) {
        //           let sum = 0,
        //             idx = 0;
        //           for (let ky = -1; ky <= 1; ky++) {
        //             for (let kx = -1; kx <= 1; kx++) {
        //               let px = 4 * ((y + ky) * w + (x + kx)) + c;
        //               sum += src[px] * kernel[idx++];
        //             }
        //           }
        //           dst[4 * (y * w + x) + c] = sum;
        //         }
        //         dst[4 * (y * w + x) + 3] = src[4 * (y * w + x) + 3];
        //       }
        //     }
        //     return dst;
        //   }
        //   for (let iter = 0; iter < iterations; iter++) {
        //     let estimateBlur = convolve(estimate);
        //     let ratio = new Float32Array(estimate.length);
        //     for (let i = 0; i < estimate.length; i++) {
        //       ratio[i] = estimateBlur[i]
        //         ? observed[i] / (estimateBlur[i] + 1e-6)
        //         : 0;
        //     }
        //     let ratioBlur = convolve(ratio);
        //     for (let i = 0; i < estimate.length; i++) {
        //       estimate[i] = Math.max(
        //         0,
        //         Math.min(255, estimate[i] * ratioBlur[i])
        //       );
        //     }
        //   }
        //   for (let i = 0; i < imgData.data.length; i++) {
        //     imgData.data[i] = estimate[i];
        //   }
        // }
        // DFT transformasi manual (hanya magnitude, untuk statistik)
        function dftMagnitude(imgData) {
          const w = imgData.width,
            h = imgData.height;
          let gray = [];
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              let idx = 4 * (y * w + x);
              let r = imgData.data[idx],
                g = imgData.data[idx + 1],
                b = imgData.data[idx + 2];
              gray.push(0.299 * r + 0.587 * g + 0.114 * b);
            }
          }
          // DFT 1D untuk baris pertama (contoh, bukan seluruh gambar)
          let N = w;
          let mag = [];
          for (let k = 0; k < N; k++) {
            let re = 0,
              im = 0;
            for (let n = 0; n < N; n++) {
              let angle = (-2 * Math.PI * k * n) / N;
              re += gray[n] * Math.cos(angle);
              im += gray[n] * Math.sin(angle);
            }
            mag.push(Math.sqrt(re * re + im * im));
          }
          // Statistik: rata-rata magnitude
          let avgMag = mag.reduce((a, b) => a + b, 0) / mag.length;
          return avgMag;
        }
      });
    </script>
  </body>
</html>
